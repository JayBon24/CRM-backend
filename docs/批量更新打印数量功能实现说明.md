# 批量更新打印数量功能实现说明

## 实现时间
2025-10-30

## 功能概述

为 `CaseDocument`（案件文档）实现了批量更新打印数量的功能，支持一次性更新多个文档的 `print_count` 字段。

## 实现内容

### 1. 序列化器

创建了两个序列化器用于验证批量更新请求：

#### DocumentPrintCountItemSerializer

```python
class DocumentPrintCountItemSerializer(serializers.Serializer):
    """单个文档打印数量项序列化器"""
    id = serializers.IntegerField(required=True, help_text="文档ID")
    print_count = serializers.IntegerField(
        required=True, 
        min_value=1, 
        max_value=99, 
        help_text="打印数量，范围：1-99"
    )
```

**验证规则：**
- `id` 必须是整数
- `print_count` 必须在 1-99 之间

#### BatchUpdatePrintCountSerializer

```python
class BatchUpdatePrintCountSerializer(serializers.Serializer):
    """批量更新打印数量序列化器"""
    documents = DocumentPrintCountItemSerializer(many=True, required=True)
    
    def validate_documents(self, value):
        """验证文档列表"""
        if not value:
            raise serializers.ValidationError("文档列表不能为空")
        
        # 检查是否有重复的ID
        ids = [item['id'] for item in value]
        if len(ids) != len(set(ids)):
            raise serializers.ValidationError("文档ID不能重复")
        
        return value
```

**验证规则：**
- 文档列表不能为空
- 文档 ID 不能重复

### 2. API 接口

在 `CaseDocumentViewSet` 中添加了 `batch_update_print_count` action：

```python
@action(detail=False, methods=['post'], url_path='batch-update-print-count')
def batch_update_print_count(self, request):
    """批量更新文档打印数量"""
    try:
        # 1. 验证请求数据
        from .serializers import BatchUpdatePrintCountSerializer
        serializer = BatchUpdatePrintCountSerializer(data=request.data)
        if not serializer.is_valid():
            return ErrorResponse(msg=f"数据验证失败: {serializer.errors}")
        
        documents_data = serializer.validated_data['documents']
        
        # 2. 使用事务批量更新
        from django.db import transaction
        
        with transaction.atomic():
            # 提取所有文档ID
            document_ids = [item['id'] for item in documents_data]
            
            # 查询对应的文档对象（只查询未删除的）
            documents = CaseDocument.objects.filter(
                id__in=document_ids,
                is_deleted=False
            )
            
            # 检查是否所有文档都存在
            found_ids = set(d.id for d in documents)
            missing_ids = set(document_ids) - found_ids
            if missing_ids:
                return ErrorResponse(
                    msg=f"部分文档不存在",
                    data={'not_found_ids': list(missing_ids)}
                )
            
            # 创建ID到print_count的映射
            print_count_map = {item['id']: item['print_count'] for item in documents_data}
            
            # 更新每个文档的print_count
            for document in documents:
                document.print_count = print_count_map[document.id]
            
            # 批量保存
            CaseDocument.objects.bulk_update(documents, ['print_count'])
            
            # 准备返回数据
            updated_documents = [
                {
                    'id': doc.id,
                    'document_name': doc.document_name,
                    'print_count': doc.print_count
                }
                for doc in documents
            ]
        
        logger.info(f"成功更新 {len(documents)} 个文档的打印数量")
        
        return DetailResponse(
            data={
                'updated_count': len(documents),
                'updated_documents': updated_documents
            },
            msg=f"成功更新 {len(documents)} 个文档的打印数量"
        )
        
    except Exception as e:
        logger.error(f"批量更新打印数量失败: {str(e)}")
        return ErrorResponse(msg=f"更新打印数量失败: {str(e)}")
```

**核心特性：**
1. **数据验证**：使用序列化器验证请求数据，确保 print_count 在 1-99 范围内
2. **事务保护**：使用 `transaction.atomic()` 确保数据一致性
3. **批量更新**：使用 `bulk_update` 提高性能
4. **错误处理**：检查文档是否存在，返回未找到的文档ID
5. **只更新未删除的文档**：`is_deleted=False`
6. **日志记录**：记录更新操作和错误

## API 使用说明

### 接口地址

```
POST /api/case/documents/batch-update-print-count/
```

### 请求格式

```json
{
  "documents": [
    {
      "id": 1,
      "print_count": 3
    },
    {
      "id": 5,
      "print_count": 2
    },
    {
      "id": 8,
      "print_count": 1
    }
  ]
}
```

### 请求参数说明

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| documents | Array | 是 | 需要更新的文档列表 |
| documents[].id | Integer | 是 | 文档ID（CaseDocument的主键） |
| documents[].print_count | Integer | 是 | 打印数量，范围：1-99 |

### 成功响应

**HTTP 状态码**：200

```json
{
  "code": 2000,
  "msg": "成功更新 3 个文档的打印数量",
  "data": {
    "updated_count": 3,
    "updated_documents": [
      {
        "id": 1,
        "document_name": "起诉状.docx",
        "print_count": 3
      },
      {
        "id": 5,
        "document_name": "答辩状.docx",
        "print_count": 2
      },
      {
        "id": 8,
        "document_name": "证据清单.pdf",
        "print_count": 1
      }
    ]
  }
}
```

### 错误响应

#### 1. 数据验证失败（文档列表为空）

```json
{
  "code": 4000,
  "msg": "数据验证失败: {'documents': ['文档列表不能为空']}"
}
```

#### 2. 打印数量超出范围

```json
{
  "code": 4000,
  "msg": "数据验证失败: {'documents': [{'print_count': ['确保该值大于或等于 1。']}]}"
}
```

#### 3. 文档ID重复

```json
{
  "code": 4000,
  "msg": "数据验证失败: {'documents': ['文档ID不能重复']}"
}
```

#### 4. 部分文档不存在

```json
{
  "code": 4000,
  "msg": "部分文档不存在",
  "data": {
    "not_found_ids": [99, 100]
  }
}
```

#### 5. 服务器错误

```json
{
  "code": 5000,
  "msg": "更新打印数量失败: [错误信息]"
}
```

## 前端调用示例

### JavaScript (Axios)

```javascript
import axios from 'axios';

// 批量更新打印数量
async function batchUpdatePrintCount(documents) {
  try {
    const response = await axios.post(
      '/api/case/documents/batch-update-print-count/',
      {
        documents: documents
      }
    );
    
    if (response.data.code === 2000) {
      console.log('打印数量更新成功:', response.data.data);
      return response.data.data;
    } else {
      console.error('更新失败:', response.data.msg);
      return null;
    }
  } catch (error) {
    console.error('请求失败:', error);
    return null;
  }
}

// 使用示例
const documentsToUpdate = [
  { id: 1, print_count: 3 },
  { id: 5, print_count: 2 },
  { id: 8, print_count: 1 }
];

batchUpdatePrintCount(documentsToUpdate);
```

### TypeScript

```typescript
interface DocumentPrintCount {
  id: number;
  print_count: number;
}

interface BatchUpdateResponse {
  code: number;
  msg: string;
  data: {
    updated_count: number;
    updated_documents: Array<{
      id: number;
      document_name: string;
      print_count: number;
    }>;
  };
}

async function batchUpdatePrintCount(
  documents: DocumentPrintCount[]
): Promise<BatchUpdateResponse | null> {
  try {
    const response = await request<BatchUpdateResponse>({
      url: '/api/case/documents/batch-update-print-count/',
      method: 'post',
      data: {
        documents
      }
    });

    if (response.code !== 2000) {
      ElMessage.error(response.msg || '更新打印数量失败');
      return null;
    }

    ElMessage.success('打印数量已更新到服务器');
    return response;
  } catch (error) {
    console.error('批量更新失败:', error);
    return null;
  }
}
```

### Vue 组件示例

```vue
<template>
  <div>
    <el-table :data="documents">
      <el-table-column prop="document_name" label="文档名称" />
      <el-table-column label="打印数量">
        <template #default="{ row }">
          <el-input-number
            v-model="row.print_count"
            :min="1"
            :max="99"
            @change="handlePrintCountChange(row)"
          />
        </template>
      </el-table-column>
    </el-table>
    
    <el-button type="primary" @click="saveAllPrintCounts">
      批量保存打印数量
    </el-button>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { ElMessage } from 'element-plus';

const documents = ref([
  { id: 1, document_name: '起诉状.docx', print_count: 1 },
  { id: 2, document_name: '答辩状.docx', print_count: 1 },
  { id: 3, document_name: '证据清单.pdf', print_count: 1 }
]);

const changedDocuments = ref(new Set());

const handlePrintCountChange = (row) => {
  changedDocuments.value.add(row.id);
};

const saveAllPrintCounts = async () => {
  // 只更新有变化的文档
  const documentsToUpdate = documents.value
    .filter(doc => changedDocuments.value.has(doc.id))
    .map(doc => ({
      id: doc.id,
      print_count: doc.print_count
    }));
  
  if (documentsToUpdate.length === 0) {
    ElMessage.info('没有需要更新的数据');
    return;
  }
  
  try {
    const response = await axios.post(
      '/api/case/documents/batch-update-print-count/',
      {
        documents: documentsToUpdate
      }
    );
    
    if (response.data.code === 2000) {
      ElMessage.success(`成功更新 ${response.data.data.updated_count} 个文档的打印数量`);
      changedDocuments.value.clear();
    } else {
      ElMessage.error(response.data.msg);
    }
  } catch (error) {
    ElMessage.error('更新失败，请重试');
    console.error(error);
  }
};
</script>
```

## 测试示例

### 使用 cURL

```bash
# 批量更新3个文档的打印数量
curl -X POST http://localhost:8000/api/case/documents/batch-update-print-count/ \
  -H "Content-Type: application/json" \
  -d '{
    "documents": [
      {"id": 1, "print_count": 3},
      {"id": 5, "print_count": 2},
      {"id": 8, "print_count": 1}
    ]
  }'
```

### 使用 Python requests

```python
import requests

url = "http://localhost:8000/api/case/documents/batch-update-print-count/"
headers = {
    "Content-Type": "application/json"
}
data = {
    "documents": [
        {"id": 1, "print_count": 3},
        {"id": 5, "print_count": 2},
        {"id": 8, "print_count": 1}
    ]
}

response = requests.post(url, json=data, headers=headers)
print(response.json())
```

### 使用 Postman

1. **Method**: POST
2. **URL**: `http://localhost:8000/api/case/documents/batch-update-print-count/`
3. **Headers**:
   - `Content-Type`: `application/json`
4. **Body** (raw JSON):
```json
{
  "documents": [
    {"id": 1, "print_count": 3},
    {"id": 5, "print_count": 2}
  ]
}
```

## 性能优化

### 1. 批量更新

使用 `bulk_update` 而非循环 `save()`：

```python
# ❌ 性能差
for document in documents:
    document.print_count = new_value
    document.save()

# ✅ 性能好
for document in documents:
    document.print_count = new_value
CaseDocument.objects.bulk_update(documents, ['print_count'])
```

### 2. 事务保护

```python
with transaction.atomic():
    # 所有更新操作
    CaseDocument.objects.bulk_update(documents, ['print_count'])
```

### 3. 只查询需要的字段

如果返回数据不需要所有字段，可以优化：

```python
documents = CaseDocument.objects.filter(
    id__in=document_ids
).only('id', 'document_name', 'print_count')
```

### 4. 分批处理大量数据

```python
BATCH_SIZE = 500

for i in range(0, len(documents_data), BATCH_SIZE):
    batch = documents_data[i:i + BATCH_SIZE]
    with transaction.atomic():
        # 处理批次
        pass
```

## 数据库影响

### 更新前

```sql
SELECT id, document_name, print_count FROM case_document WHERE id IN (1, 5, 8);

-- 结果：
-- id | document_name      | print_count
-- 1  | 起诉状.docx        | 1
-- 5  | 答辩状.docx        | 1
-- 8  | 证据清单.pdf       | 1
```

### 更新后

```sql
SELECT id, document_name, print_count FROM case_document WHERE id IN (1, 5, 8);

-- 结果：
-- id | document_name      | print_count
-- 1  | 起诉状.docx        | 3
-- 5  | 答辩状.docx        | 2
-- 8  | 证据清单.pdf       | 1
```

## 注意事项

### 1. 打印数量范围

- 最小值：1
- 最大值：99
- 超出范围会被序列化器自动拦截

### 2. 只更新未删除的文档

查询时使用 `is_deleted=False`，已删除的文档不会被更新

### 3. 文档必须存在

如果请求的文档ID不存在，会返回错误并列出不存在的ID

### 4. 事务回滚

如果更新过程中出现任何错误，所有更新都会回滚，保证数据一致性

## 相关文件

- **视图**: `case_management/views.py` - `CaseDocumentViewSet.batch_update_print_count()`
- **序列化器**: `case_management/serializers.py` - `BatchUpdatePrintCountSerializer`
- **模型**: `case_management/models.py` - `CaseDocument`
- **URL配置**: `case_management/urls.py` - 自动注册

## 总结

### 实现功能

✅ **已实现：**
- [x] 批量更新文档打印数量 API
- [x] 数据验证（范围：1-99）
- [x] 事务保护
- [x] 批量更新优化
- [x] 错误处理（文档不存在检查）
- [x] 日志记录
- [x] 完整的响应数据

### 性能特点

- 使用批量更新减少数据库操作
- 事务保证数据一致性
- 只更新未删除的文档
- 支持一次更新多个文档

### 安全特性

- 数据验证（范围检查）
- ID重复检查
- 事务回滚机制
- 日志记录所有操作


# 媒体文件权限控制说明

## 概述

本系统已实现对所有媒体文件（用户上传的文件）的权限控制，确保只有授权用户才能访问这些文件。

### ⚠️ 重要说明：MEDIA vs STATIC

Django 区分两种不同类型的文件：

| 类型 | 用途 | 路径 | 权限控制 | 示例 |
|------|------|------|---------|------|
| **STATIC 文件** | 网站静态资源 | `/static/` | ❌ 无限制，公开访问 | CSS、JS、图片、字体等 |
| **MEDIA 文件** | 用户上传的文件 | `/media/` | ✅ 需要登录访问 | 案件文档、上传的文书等 |

**本文档只涉及 MEDIA 文件的权限控制，网站的静态资源（STATIC）不受影响，仍可公开访问。**

## 当前权限策略

**要求：用户必须登录才能访问媒体文件**

- 未登录用户访问媒体文件将返回 401 或 403 错误
- 所有登录用户都可以访问任何媒体文件

## 文件结构

```
case_management/
  └── media_views.py          # 媒体文件权限控制视图

application/
  ├── settings.py             # MEDIA_ROOT 和 MEDIA_URL 配置
  └── urls.py                 # 媒体文件路由配置
```

## 配置说明

### 1. Settings 配置

```python
# application/settings.py
MEDIA_ROOT = "media"  # 媒体文件在服务器上的物理存储目录
MEDIA_URL = "/media/"  # 媒体文件的URL访问前缀（已启用权限控制，需登录才能访问）
```

### 2. URL 路由配置

```python
# application/urls.py

# MEDIA 文件：需要权限控制
re_path(r'^media/(?P<file_path>.+)$', serve_protected_media, name='protected_media'),

# STATIC 文件：仍然公开访问（这行保持不变）
+ static(settings.STATIC_URL, document_root=settings.STATIC_URL)
```

- 所有对 `/media/*` 的请求都会经过 `serve_protected_media` 视图进行权限验证
- 所有对 `/static/*` 的请求仍然直接访问，不需要权限验证

## 使用示例

### 前端访问媒体文件

```javascript
// 需要在请求头中携带认证 token
fetch('http://your-domain.com/media/cases/17/document.pdf', {
  headers: {
    'Authorization': `Bearer ${token}`  // JWT token
  }
})
.then(response => response.blob())
.then(blob => {
  // 处理文件
  const url = window.URL.createObjectURL(blob);
  window.open(url);
});
```

### 在 HTML 中直接引用

如果页面本身需要登录，可以直接使用：

```html
<!-- 浏览器会自动携带 session/cookie -->
<img src="/media/cases/17/avatar.jpg" />
<a href="/media/cases/17/document.pdf" download>下载文档</a>
```

## 未来权限扩展

`case_management/media_views.py` 中已经预留了权限扩展的位置和示例代码。

### 扩展方式 1：基于案件的权限控制

```python
# 在 serve_protected_media 函数中添加
if 'cases/' in file_path:
    case_id = extract_case_id_from_path(file_path)
    if not has_case_access_permission(request.user, case_id):
        return Response(
            {"error": "您没有权限访问此案件的文件"},
            status=status.HTTP_403_FORBIDDEN
        )
```

实现 `has_case_access_permission` 函数：

```python
def has_case_access_permission(user, case_id):
    """检查用户是否有权限访问指定案件的文件"""
    from .models import CaseManagement
    try:
        case = CaseManagement.objects.get(id=case_id, is_deleted=False)
        
        # 案件创建者可以访问
        if case.creator == user:
            return True
        
        # 案件负责人可以访问
        if case.draft_person == user:
            return True
        
        # 管理员可以访问
        if user.is_superuser:
            return True
        
        # 其他协作人员（如果有协作人员字段）
        # if user in case.collaborators.all():
        #     return True
        
        return False
    except CaseManagement.DoesNotExist:
        return False
```

### 扩展方式 2：基于 Django 权限系统

```python
# 检查用户是否有查看文档的权限
if not request.user.has_perm('case_management.view_casedocument'):
    return Response(
        {"error": "您没有查看文档的权限"},
        status=status.HTTP_403_FORBIDDEN
    )
```

### 扩展方式 3：基于文件类型的权限控制

```python
# 限制特定文件类型的访问
file_ext = os.path.splitext(file_path)[1].lower()
sensitive_types = ['.pdf', '.docx', '.doc']

if file_ext in sensitive_types:
    if not user_has_document_permission(request.user):
        return Response(
            {"error": "您没有权限访问此类型的文件"},
            status=status.HTTP_403_FORBIDDEN
        )
```

### 扩展方式 4：基于用户角色

```python
# 检查用户角色
user_roles = request.user.role.values_list('key', flat=True)

# 只有律师和管理员可以下载原始文件
if file_path.startswith('cases/') and 'original' in file_path:
    if not any(role in user_roles for role in ['lawyer', 'admin']):
        return Response(
            {"error": "只有律师和管理员可以下载原始文件"},
            status=status.HTTP_403_FORBIDDEN
        )
```

## 开发环境临时禁用权限控制

如果在开发环境需要临时禁用权限控制，可以修改 `application/urls.py`：

```python
# 取消下面这行的注释
+ static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

同时注释掉权限控制路由：

```python
# re_path(r'^media/(?P<file_path>.+)$', serve_protected_media, name='protected_media'),
```

**注意：生产环境务必启用权限控制！**

## 安全特性

### 1. 路径穿越防护

系统会检查请求的文件路径，防止访问 MEDIA_ROOT 之外的文件：

```python
# 安全检查：防止路径穿越攻击
full_path = os.path.abspath(full_path)
media_root = os.path.abspath(settings.MEDIA_ROOT)

if not full_path.startswith(media_root):
    return Response({"error": "非法的文件路径"}, status=403)
```

### 2. 认证验证

所有请求都必须通过 Django REST framework 的认证：

```python
@permission_classes([IsAuthenticated])  # 要求用户必须登录
```

### 3. 文件存在性检查

在返回文件前会检查文件是否存在：

```python
if not os.path.exists(full_path) or not os.path.isfile(full_path):
    raise Http404("文件不存在")
```

## 常见问题

### Q1: 前端访问媒体文件返回 401 错误？

**A:** 确保请求头中携带了正确的认证 token：

```javascript
headers: {
    'Authorization': 'Bearer YOUR_JWT_TOKEN'
}
```

### Q2: 如何获取文件的完整 URL？

**A:** 在后端使用：

```python
from django.conf import settings

file_url = f"{settings.MEDIA_URL}cases/17/document.pdf"
# 结果: /media/cases/17/document.pdf
```

### Q3: Nginx 部署时的配置

如果使用 Nginx，需要确保媒体文件请求被转发到 Django：

```nginx
# 不要直接处理 /media/，让 Django 处理
# location /media/ {
#     alias /path/to/media/;  # 不要这样配置
# }

# 应该让所有请求都经过 Django
location / {
    proxy_pass http://django_backend;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
}
```

### Q4: 性能优化建议

对于大文件下载，可以考虑：

1. **使用 X-Accel-Redirect（Nginx）**：
   ```python
   # Django 进行权限验证后，让 Nginx 实际传输文件
   response = HttpResponse()
   response['X-Accel-Redirect'] = f'/protected/{file_path}'
   return response
   ```

2. **使用 X-Sendfile（Apache）**：
   ```python
   response = HttpResponse()
   response['X-Sendfile'] = full_path
   return response
   ```

3. **添加缓存控制**：
   ```python
   response['Cache-Control'] = 'private, max-age=3600'
   ```

## 测试

### 测试未登录访问

```bash
curl http://localhost:8000/media/cases/17/document.pdf
# 应该返回 401 Unauthorized
```

### 测试登录后访问

```bash
curl -H "Authorization: Bearer YOUR_TOKEN" \
     http://localhost:8000/media/cases/17/document.pdf
# 应该返回文件内容
```

## 相关文件

- `case_management/media_views.py` - 权限控制视图
- `application/settings.py` - 媒体文件配置
- `application/urls.py` - URL 路由配置

## 更新日志

- 2025-10-29: 实现基础的登录权限控制，预留权限扩展接口

# /media/目录的文件说明
- `/media/cases/{case_id}/{document_name}
- `/media/cases/{case_id}/case_documents  : 是案件文书
# 固定目录模板配置
CASE_FOLDER_TEMPLATES = [
    {
        'folder_name': '案件文书',
        'folder_path': '/case_documents',
        'sort_order': 1,
        'description': '存放模板生成的各类法律文书'
    },
    {
        'folder_name': '正卷目录',
        'folder_path': '/main_volume',
        'sort_order': 2,
        'description': '存放案件正卷相关文档'
    },
    {
        'folder_name': '副卷目录',
        'folder_path': '/sub_volume',
        'sort_order': 3,
        'description': '存放案件副卷相关文档'
    },
    {
        'folder_name': '执行案内目录',
        'folder_path': '/execution_files',
        'sort_order': 4,
        'description': '存放执行阶段相关文档'
    },
    {
        'folder_name': '临时文件',
        'folder_path': '/temp_files',
        'sort_order': 5,
        'description': '存放临时性文件'
    }
]

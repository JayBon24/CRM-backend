# 批量打印选中状态保存功能 - 后端修改文档

## 一、功能概述

本次功能增强要求在批量打印功能中，除了保存打印数量（`print_count`）外，还需要保存文档的选中状态（`is_selected`）。这样用户下次打开批量打印对话框时，可以恢复之前的选中状态。

## 二、数据库修改

### 2.1 添加字段

在 `case_document` 表中添加 `is_selected` 字段：

```sql
-- 添加 is_selected 字段（布尔类型，默认值为 False）
ALTER TABLE case_document 
ADD COLUMN is_selected BOOLEAN DEFAULT FALSE NOT NULL;

-- 添加注释
COMMENT ON COLUMN case_document.is_selected IS '文档在批量打印中是否被选中';
```

**字段说明：**
- **字段名**：`is_selected`
- **类型**：`BOOLEAN`（或 `BooleanField`）
- **默认值**：`False`
- **允许为空**：否（`NOT NULL`）
- **含义**：标记文档在批量打印对话框中是否被选中

### 2.2 数据库迁移文件（Django）

如果使用 Django，创建迁移文件：

```python
# migrations/xxxx_add_is_selected_to_case_document.py

from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [
        ('case', 'previous_migration'),  # 替换为实际的依赖
    ]

    operations = [
        migrations.AddField(
            model_name='casedocument',
            name='is_selected',
            field=models.BooleanField(default=False, verbose_name='是否选中'),
        ),
    ]
```

## 三、模型修改

### 3.1 Django 模型修改

在 `CaseDocument` 模型中添加字段：

```python
# models.py

class CaseDocument(models.Model):
    # ... 现有字段 ...
    
    print_count = models.IntegerField(default=1, verbose_name='打印数量')
    is_selected = models.BooleanField(default=False, verbose_name='是否选中')
    
    class Meta:
        verbose_name = '案件文档'
        verbose_name_plural = '案件文档'
```

### 3.2 序列化器修改

在序列化器中添加 `is_selected` 字段：

```python
# serializers.py

class CaseDocumentSerializer(serializers.ModelSerializer):
    # ... 现有字段 ...
    
    print_count = serializers.IntegerField(default=1, read_only=False)
    is_selected = serializers.BooleanField(default=False, read_only=False)
    
    class Meta:
        model = CaseDocument
        fields = [
            # ... 现有字段 ...
            'print_count',
            'is_selected',
        ]
```

### 3.3 文档树序列化器修改

在返回文档树时，需要包含 `is_selected` 字段：

```python
# serializers.py 或 views.py

class DocumentTreeNodeSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    label = serializers.CharField()
    path = serializers.CharField()
    type = serializers.CharField()  # 'folder' 或 'file'
    url = serializers.URLField(required=False, allow_null=True)
    document_id = serializers.IntegerField(required=False, allow_null=True)
    file_size = serializers.IntegerField(required=False, allow_null=True)
    print_count = serializers.IntegerField(required=False, allow_null=True)
    is_selected = serializers.BooleanField(required=False, allow_null=True)  # 新增
    children = serializers.ListField(required=False, allow_null=True)
    create_datetime = serializers.DateTimeField(required=False, allow_null=True)
    update_datetime = serializers.DateTimeField(required=False, allow_null=True)
```

## 四、API 接口修改

### 4.1 批量更新打印数量接口

**接口路径**：`POST /api/case/documents/batch-update-print-count/`

**请求参数修改**：

```json
{
  "documents": [
    {
      "id": 123,              // 文档ID（document_id）
      "print_count": 2,       // 打印数量
      "is_selected": true     // 是否选中（新增字段）
    },
    {
      "id": 124,
      "print_count": 1,
      "is_selected": false    // 未选中的文档也需要保存
    }
  ]
}
```

**后端实现示例**：

```python
# views.py

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def batch_update_print_count(request):
    """
    批量更新打印数量和选中状态
    """
    documents_data = request.data.get('documents', [])
    
    if not documents_data:
        return Response({
            'code': 4000,
            'msg': '文档列表不能为空',
            'data': None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    updated_count = 0
    errors = []
    
    for doc_data in documents_data:
        doc_id = doc_data.get('id')
        print_count = doc_data.get('print_count', 1)
        is_selected = doc_data.get('is_selected', False)  # 新增
        
        if not doc_id:
            errors.append(f'文档ID不能为空: {doc_data}')
            continue
        
        try:
            document = CaseDocument.objects.get(id=doc_id)
            document.print_count = print_count
            document.is_selected = is_selected  # 新增
            document.save()
            updated_count += 1
        except CaseDocument.DoesNotExist:
            errors.append(f'文档不存在: {doc_id}')
        except Exception as e:
            errors.append(f'更新文档失败 {doc_id}: {str(e)}')
    
    if errors:
        return Response({
            'code': 4000,
            'msg': f'部分更新失败: {"; ".join(errors)}',
            'data': {
                'updated_count': updated_count,
                'errors': errors
            }
        }, status=status.HTTP_200_OK)
    
    return Response({
        'code': 2000,
        'msg': f'成功更新 {updated_count} 个文档',
        'data': {
            'updated_count': updated_count
        }
    })
```

### 4.2 获取文档树接口

**接口路径**：`GET /api/case/cases/{case_id}/document_tree/`

**响应数据修改**：

需要在返回的文档树节点中包含 `is_selected` 字段：

```python
# views.py

def get_document_tree(case_id):
    """
    获取案件文档树
    """
    # ... 现有逻辑 ...
    
    def build_tree_node(folder, case_documents):
        """构建树节点"""
        node = {
            'id': folder.id,
            'label': folder.folder_name,
            'path': folder.folder_path,
            'type': 'folder',
            'children': []
        }
        
        # 获取该文件夹下的文档
        folder_docs = case_documents.filter(folder_id=folder.id)
        
        for doc in folder_docs:
            doc_node = {
                'id': doc.id,
                'label': doc.document_name,
                'path': doc.file_path or '',
                'type': 'file',
                'document_id': doc.id,
                'file_size': doc.file_size,
                'print_count': doc.print_count,  # 现有字段
                'is_selected': doc.is_selected,  # 新增字段
                'url': build_file_url(doc),  # 构建文件URL
                'create_datetime': doc.create_datetime.isoformat() if doc.create_datetime else None,
                'update_datetime': doc.update_datetime.isoformat() if doc.update_datetime else None,
            }
            node['children'].append(doc_node)
        
        return node
    
    # ... 构建树结构 ...
    
    return Response({
        'code': 2000,
        'msg': '获取文档树成功',
        'data': tree_data
    })
```

**响应示例**：

```json
{
  "code": 2000,
  "msg": "获取文档树成功",
  "data": [
    {
      "id": 1,
      "label": "案件文档",
      "path": "/",
      "type": "folder",
      "children": [
        {
          "id": 123,
          "label": "委托代理合同.docx",
          "path": "/documents/123.docx",
          "type": "file",
          "document_id": 123,
          "file_size": 102400,
          "print_count": 2,
          "is_selected": true,    // 新增字段
          "url": "http://example.com/api/files/123.docx",
          "create_datetime": "2024-01-01T00:00:00Z",
          "update_datetime": "2024-01-02T00:00:00Z"
        },
        {
          "id": 124,
          "label": "授权委托书.docx",
          "path": "/documents/124.docx",
          "type": "file",
          "document_id": 124,
          "file_size": 51200,
          "print_count": 1,
          "is_selected": false,   // 新增字段
          "url": "http://example.com/api/files/124.docx",
          "create_datetime": "2024-01-01T00:00:00Z",
          "update_datetime": "2024-01-02T00:00:00Z"
        }
      ]
    }
  ]
}
```

## 五、前端请求格式

### 5.1 保存打印数量和选中状态

前端调用保存接口时，会发送所有文档（包括未选中的文档）的数据：

```javascript
// 前端请求示例
POST /api/case/documents/batch-update-print-count/
{
  "documents": [
    {
      "id": 123,              // document_id
      "print_count": 2,        // 打印数量
      "is_selected": true      // 选中状态
    },
    {
      "id": 124,
      "print_count": 1,
      "is_selected": false     // 未选中的文档也需要保存
    },
    // ... 更多文档
  ]
}
```

**重要说明**：
- 前端会发送**所有文档**的数据，包括未选中的文档
- 未选中的文档的 `is_selected` 为 `false`
- 后端需要更新所有接收到的文档的 `print_count` 和 `is_selected` 字段

### 5.2 读取文档树

前端在获取文档树时，会从响应中读取 `is_selected` 字段：

```javascript
// 前端读取示例
GET /api/case/cases/{case_id}/document_tree/

// 响应中的文档节点包含 is_selected 字段
{
  "code": 2000,
  "data": [
    {
      "type": "file",
      "document_id": 123,
      "print_count": 2,
      "is_selected": true,  // 前端使用此字段恢复选中状态
      // ... 其他字段
    }
  ]
}
```

## 六、测试要点

### 6.1 数据库测试

1. 验证 `is_selected` 字段已添加到数据库
2. 验证字段默认值为 `False`
3. 验证字段不允许为空

### 6.2 API 测试

1. **批量更新接口测试**：
   - 测试只更新 `print_count`（向后兼容）
   - 测试同时更新 `print_count` 和 `is_selected`
   - 测试更新未选中的文档（`is_selected: false`）
   - 测试更新选中的文档（`is_selected: true`）
   - 测试批量更新多个文档

2. **文档树接口测试**：
   - 验证返回的文档节点包含 `is_selected` 字段
   - 验证 `is_selected` 字段的值正确（`true`/`false`）
   - 验证未设置过选中状态的文档返回 `is_selected: false`（默认值）

3. **数据一致性测试**：
   - 保存选中状态后，重新获取文档树，验证选中状态已保存
   - 验证未选中的文档也能正确保存和读取

### 6.3 前端交互测试

1. 打开批量打印对话框，验证之前保存的选中状态正确恢复
2. 修改选中状态和打印数量，点击"保存打印数量"，验证保存成功
3. 关闭对话框，重新打开，验证选中状态和打印数量已恢复

## 七、注意事项

1. **向后兼容**：
   - 如果前端请求中没有 `is_selected` 字段，后端应该保持原有行为（不更新 `is_selected`）
   - 或者默认设置为 `False`

2. **数据完整性**：
   - 前端会发送所有文档的数据，后端需要更新所有接收到的文档
   - 未选中的文档也需要保存 `is_selected: false`

3. **默认值处理**：
   - 新创建的文档或未设置过选中状态的文档，`is_selected` 默认为 `False`
   - 前端在读取时，如果 `is_selected` 为 `undefined` 或 `null`，应该默认为 `true`（向后兼容，保持原有行为）

4. **性能考虑**：
   - 批量更新时，可以考虑使用 `bulk_update` 提高性能
   - 如果文档数量很大，可以考虑分批更新

## 八、迁移步骤

1. **第一步**：添加数据库字段
   ```sql
   ALTER TABLE case_document ADD COLUMN is_selected BOOLEAN DEFAULT FALSE NOT NULL;
   ```

2. **第二步**：更新模型和序列化器
   - 在 `CaseDocument` 模型中添加 `is_selected` 字段
   - 在序列化器中添加 `is_selected` 字段

3. **第三步**：更新 API 接口
   - 修改批量更新接口，支持更新 `is_selected` 字段
   - 修改文档树接口，返回 `is_selected` 字段

4. **第四步**：测试验证
   - 运行数据库迁移
   - 测试 API 接口
   - 与前端联调测试

5. **第五步**：部署上线
   - 先部署后端
   - 再部署前端

## 九、常见问题

### Q1: 如果前端请求中没有 `is_selected` 字段怎么办？

**A**: 后端应该保持向后兼容，如果请求中没有 `is_selected` 字段，可以：
- 不更新 `is_selected` 字段（保持原值）
- 或者默认设置为 `False`

推荐方案：不更新 `is_selected` 字段，保持原值。

### Q2: 未选中的文档也需要保存吗？

**A**: 是的，前端会发送所有文档的数据（包括未选中的），后端需要更新所有接收到的文档。这样可以确保：
- 用户取消选中的文档状态被正确保存
- 下次打开对话框时，未选中的文档保持未选中状态

### Q3: 如果文档树中有很多文档，会影响性能吗？

**A**: 
- 文档树接口只是读取数据，不会影响性能
- 批量更新接口如果文档数量很大（>100），可以考虑分批更新或使用 `bulk_update`

## 十、参考代码

### 10.1 完整的批量更新接口实现（Django）

```python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from .models import CaseDocument

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def batch_update_print_count(request):
    """
    批量更新打印数量和选中状态
    
    请求格式：
    {
        "documents": [
            {
                "id": 123,
                "print_count": 2,
                "is_selected": true
            },
            ...
        ]
    }
    """
    documents_data = request.data.get('documents', [])
    
    if not documents_data:
        return Response({
            'code': 4000,
            'msg': '文档列表不能为空',
            'data': None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    updated_documents = []
    errors = []
    
    for doc_data in documents_data:
        doc_id = doc_data.get('id')
        
        if not doc_id:
            errors.append(f'文档ID不能为空: {doc_data}')
            continue
        
        try:
            document = CaseDocument.objects.get(id=doc_id)
            
            # 更新打印数量（如果提供）
            if 'print_count' in doc_data:
                document.print_count = doc_data.get('print_count', 1)
            
            # 更新选中状态（如果提供）
            if 'is_selected' in doc_data:
                document.is_selected = doc_data.get('is_selected', False)
            
            document.save()
            updated_documents.append({
                'id': document.id,
                'print_count': document.print_count,
                'is_selected': document.is_selected
            })
            
        except CaseDocument.DoesNotExist:
            errors.append(f'文档不存在: {doc_id}')
        except Exception as e:
            errors.append(f'更新文档失败 {doc_id}: {str(e)}')
    
    if errors and not updated_documents:
        # 全部失败
        return Response({
            'code': 4000,
            'msg': f'更新失败: {"; ".join(errors)}',
            'data': {
                'updated_count': 0,
                'errors': errors
            }
        }, status=status.HTTP_400_BAD_REQUEST)
    
    response_data = {
        'code': 2000,
        'msg': f'成功更新 {len(updated_documents)} 个文档',
        'data': {
            'updated_count': len(updated_documents),
            'updated_documents': updated_documents
        }
    }
    
    if errors:
        response_data['data']['errors'] = errors
        response_data['msg'] += f'，{len(errors)} 个文档更新失败'
    
    return Response(response_data)
```

### 10.2 文档树构建函数（包含 is_selected）

```python
def build_document_tree(case_id):
    """
    构建文档树，包含 is_selected 字段
    """
    from .models import CaseFolder, CaseDocument
    
    # 获取所有文件夹
    folders = CaseFolder.objects.filter(
        case_id=case_id,
        is_deleted=False
    ).order_by('sort_order', 'id')
    
    # 获取所有文档
    documents = CaseDocument.objects.filter(
        case_id=case_id,
        is_deleted=False
    )
    
    # 构建文件夹映射
    folder_map = {folder.id: folder for folder in folders}
    
    # 构建树结构
    def build_tree_node(folder):
        node = {
            'id': folder.id,
            'label': folder.folder_name,
            'path': folder.folder_path,
            'type': 'folder',
            'children': []
        }
        
        # 获取该文件夹下的文档
        folder_docs = documents.filter(folder_id=folder.id)
        
        for doc in folder_docs:
            doc_node = {
                'id': doc.id,
                'label': doc.document_name,
                'path': doc.file_path or '',
                'type': 'file',
                'document_id': doc.id,
                'file_size': doc.file_size,
                'print_count': doc.print_count,
                'is_selected': doc.is_selected,  # 新增字段
                'url': build_file_url(doc),  # 构建文件URL
                'create_datetime': doc.create_datetime.isoformat() if doc.create_datetime else None,
                'update_datetime': doc.update_datetime.isoformat() if doc.update_datetime else None,
            }
            node['children'].append(doc_node)
        
        # 处理子文件夹
        child_folders = [f for f in folders if f.parent_id == folder.id]
        for child_folder in child_folders:
            node['children'].append(build_tree_node(child_folder))
        
        return node
    
    # 构建根节点
    root_folders = [f for f in folders if f.parent_id is None]
    tree_data = [build_tree_node(folder) for folder in root_folders]
    
    return tree_data
```

---

**文档版本**：v1.0  
**最后更新**：2024-01-XX  
**作者**：开发团队

